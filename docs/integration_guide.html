<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Integration: How It All Fits Together</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }
        
        .content {
            padding: 40px;
        }
        
        section {
            margin-bottom: 50px;
        }
        
        h2 {
            color: #4facfe;
            font-size: 1.8em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #4facfe;
        }
        
        h3 {
            color: #00f2fe;
            font-size: 1.3em;
            margin-top: 25px;
            margin-bottom: 15px;
        }
        
        h4 {
            color: #2c3e50;
            font-size: 1.1em;
            margin-top: 15px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        p {
            margin-bottom: 15px;
            line-height: 1.8;
        }
        
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d63384;
        }
        
        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid #4facfe;
            font-size: 0.95em;
            line-height: 1.5;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            border-radius: 8px;
            overflow: hidden;
        }
        
        th {
            background: #4facfe;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        
        .info-box {
            background: #d1ecf1;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #4facfe;
            margin: 20px 0;
        }
        
        .success-box {
            background: #d4edda;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .emoji {
            font-size: 1.3em;
            margin-right: 10px;
        }
        
        .flow-diagram {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #4facfe;
            font-family: monospace;
            white-space: pre-wrap;
            margin: 20px 0;
            line-height: 2;
        }
        
        .component {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4facfe;
            margin: 15px 0;
        }
        
        .component h4 {
            color: #4facfe;
            margin-top: 0;
        }
        
        .example {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
            margin: 15px 0;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4facfe;
        }
        
        .comparison-box h4 {
            color: #4facfe;
            margin-top: 0;
        }
        
        footer {
            background: #f8f9fa;
            padding: 30px 40px;
            border-top: 1px solid #ecf0f1;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.95em;
        }
        
        @media (max-width: 768px) {
            header h1 { font-size: 2em; }
            .comparison { grid-template-columns: 1fr; }
            .content { padding: 20px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß© Complete Integration Guide</h1>
            <p>How cubepos, CubeSymmetry, and permcube work together in Kociemba's algorithm</p>
        </header>
        
        <div class="content">
            <!-- Big Picture -->
            <section id="bigpicture">
                <h2><span class="emoji">üéØ</span>The Big Picture</h2>
                
                <div class="flow-diagram">
Scrambled Cube (physical or notation)
         ‚Üì
    ‚¨áÔ∏è  PARSE
         ‚Üì
   cubepos (20 bytes)
    Complete state: all corner/edge positions + orientations
         ‚Üì
    ‚¨áÔ∏è  CONVERT
         ‚Üì
CubeSymmetry (6 bytes)
 Phase 1 coordinates: corner_ori, edge_ori, edge_perm
    Only what matters for G1 state
         ‚Üì
    ‚¨áÔ∏è  PHASE 1 SEARCH
         ‚Üì
  Get to G1 subgroup
  (orientations solved, middle edges in place)
  Max: 12 moves
         ‚Üì
    ‚¨áÔ∏è  CONVERT
         ‚Üì
   permcube (9 bytes)
  Phase 2 coordinates: edge positions, corner positions
      (orientations already solved)
         ‚Üì
    ‚¨áÔ∏è  PHASE 2 SEARCH
         ‚Üì
   Solve permutations
   Max: 18 moves
         ‚Üì
    ‚¨áÔ∏è  DONE
         ‚Üì
      SOLUTION! ‚ú®
   (‚â§ 20 total moves)
                </div>
                
                <div class="success-box">
                    <p><strong>The Kociemba Algorithm is elegant:</strong> It's not about brute force‚Äîit's about smart representation!</p>
                </div>
            </section>
            
            <!-- The Three Data Structures -->
            <section id="structures">
                <h2><span class="emoji">üì¶</span>The Three Core Data Structures</h2>
                
                <div class="comparison">
                    <div class="component">
                        <h4>1Ô∏è‚É£ cubepos</h4>
                        <p><strong>Purpose:</strong> Complete state</p>
                        <p><strong>Size:</strong> 20 bytes</p>
                        <p><strong>Stores:</strong></p>
                        <ul>
                            <li>8 corners (position + orientation)</li>
                            <li>12 edges (position + orientation)</li>
                        </ul>
                        <p><strong>When used:</strong></p>
                        <ul>
                            <li>Input/output</li>
                            <li>General cube manipulation</li>
                        </ul>
                    </div>
                    
                    <div class="component">
                        <h4>2Ô∏è‚É£ CubeSymmetry</h4>
                        <p><strong>Purpose:</strong> Phase 1 search</p>
                        <p><strong>Size:</strong> 6 bytes</p>
                        <p><strong>Stores:</strong></p>
                        <ul>
                            <li>csymm: corner orientations</li>
                            <li>eosymm: edge orientations</li>
                            <li>epsymm: middle edge placement</li>
                        </ul>
                        <p><strong>When used:</strong></p>
                        <ul>
                            <li>Phase 1 search</li>
                            <li>Pruning lookups</li>
                        </ul>
                    </div>
                    
                    <div class="component">
                        <h4>3Ô∏è‚É£ permcube</h4>
                        <p><strong>Purpose:</strong> Phase 2 search</p>
                        <p><strong>Size:</strong> 9 bytes</p>
                        <p><strong>Stores:</strong></p>
                        <ul>
                            <li>Edge permutations (3 layers)</li>
                            <li>Corner permutations</li>
                            <li>NO orientations (solved!)</li>
                        </ul>
                        <p><strong>When used:</strong></p>
                        <ul>
                            <li>Phase 2 search</li>
                            <li>Pruning lookups</li>
                        </ul>
                    </div>
                </div>
            </section>
            
            <!-- The Algorithm Phases -->
            <section id="phases">
                <h2><span class="emoji">‚öôÔ∏è</span>Phase 1: Orientation Solving</h2>
                
                <h3>Goal: Reach G1 Subgroup</h3>
                <p><strong>G1 state means:</strong></p>
                <ul>
                    <li>‚úÖ All corners are oriented correctly (orientation = 0 for all)</li>
                    <li>‚úÖ All edges are oriented correctly (flipped = 0 for all)</li>
                    <li>‚úÖ All 4 middle-layer edges are in the middle layer</li>
                    <li>‚úÖ Top 4 edges in top layer, bottom 4 edges in bottom layer</li>
                </ul>
                
                <div class="info-box">
                    <p><strong>Why this goal?</strong> From any G1 state, you can solve the cube using only U, D, F2, B2, R2, L2 moves. No full-face rotations needed, which severely limits the search space.</p>
                </div>
                
                <h3>Phase 1 Algorithm</h3>
                <pre>PHASE 1 SEARCH:
  
  Input: cubepos (scrambled cube)
  
  Step 1: Convert to CubeSymmetry
    cp = cubepos.to_cubesymmetry()
    
  Step 2: Iterative Deepening
    for depth = 1 to 12:
        result = depth_first_search(cp, depth, 0)
        if result != NULL:
            return result  // Found solution at this depth
  
  Step 3: Depth-First Search
    dfs(state, max_depth, current_depth):
        if state == G1_STATE:
            return found_solution()
        
        if current_depth >= max_depth:
            return NULL  // Too deep
        
        min_moves = pruning_table[state]
        remaining = max_depth - current_depth
        
        if min_moves > remaining:
            return NULL  // PRUNE: can't possibly reach G1
        
        for each valid move:
            new_state = state.move(move)
            result = dfs(new_state, max_depth, current_depth + 1)
            if result != NULL:
                return result
        
        return NULL
</pre>
                
                <h3>Key Phase 1 Properties</h3>
                <table>
                    <tr>
                        <th>Property</th>
                        <th>Value</th>
                    </tr>
                    <tr>
                        <td>State space size</td>
                        <td>~2.2 billion</td>
                    </tr>
                    <tr>
                        <td>Maximum depth</td>
                        <td>12 moves</td>
                    </tr>
                    <tr>
                        <td>Allowed moves</td>
                        <td>All 18 face turns</td>
                    </tr>
                    <tr>
                        <td>Pruning table size</td>
                        <td>~10 MB</td>
                    </tr>
                    <tr>
                        <td>Typical Phase 1 depth</td>
                        <td>8-10 moves</td>
                    </tr>
                </table>
                
                <h2><span class="emoji">üéØ</span>Phase 2: Permutation Solving</h2>
                
                <h3>Goal: Solve the Cube</h3>
                <p>Given a G1 state, solve completely using only position changes (orientations already solved!).</p>
                
                <h3>Phase 2 Algorithm</h3>
                <pre>PHASE 2 SEARCH:
  
  Input: CubeSymmetry from Phase 1 (in G1 state)
  
  Step 1: Convert to permcube
    pc = phase1_state.to_permcube()
    
  Step 2: Iterative Deepening
    for depth = 1 to 18:
        result = depth_first_search(pc, depth, 0)
        if result != NULL:
            return result  // Found complete solution
  
  Step 3: Depth-First Search (same pattern)
    dfs(state, max_depth, current_depth):
        if state == SOLVED_STATE:
            return found_solution()
        
        if current_depth >= max_depth:
            return NULL
        
        min_moves = phase2_pruning_table[state]
        remaining = max_depth - current_depth
        
        if min_moves > remaining:
            return NULL  // PRUNE
        
        for each valid move (U, D, F2, B2, R2, L2):
            new_state = state.move(move)
            result = dfs(new_state, max_depth, current_depth + 1)
            if result != NULL:
                return result
        
        return NULL
</pre>
                
                <h3>Key Phase 2 Properties</h3>
                <table>
                    <tr>
                        <th>Property</th>
                        <th>Value</th>
                    </tr>
                    <tr>
                        <td>State space size</td>
                        <td>~43.2 billion</td>
                    </tr>
                    <tr>
                        <td>Maximum depth</td>
                        <td>18 moves</td>
                    </tr>
                    <tr>
                        <td>Allowed moves</td>
                        <td>Only 12 (half-turns + U/D)</td>
                    </tr>
                    <tr>
                        <td>Pruning table size</td>
                        <td>~40 MB</td>
                    </tr>
                    <tr>
                        <td>Typical Phase 2 depth</td>
                        <td>5-10 moves</td>
                    </tr>
                </table>
                
                <div class="highlight">
                    <p><strong>Phase 1 + Phase 2:</strong> Total max 12 + 18 = 30 moves theoretically, but in practice ‚â§ 20 moves (God's Number!)</p>
                </div>
            </section>
            
            <!-- Lookup Tables -->
            <section id="lookups">
                <h2><span class="emoji">üìö</span>Lookup Tables: The Speed Secret</h2>
                
                <p>All operations use pre-computed lookup tables instead of heavy computations:</p>
                
                <h3>Move Application Tables</h3>
                <table>
                    <tr>
                        <th>Structure</th>
                        <th>Table</th>
                        <th>Size</th>
                        <th>Operation</th>
                    </tr>
                    <tr>
                        <td><strong>cubepos</strong></td>
                        <td>edge_trans[18][24]</td>
                        <td>432 B</td>
                        <td>Cubie encoding transformation</td>
                    </tr>
                    <tr>
                        <td><strong>cubepos</strong></td>
                        <td>corner_trans[18][24]</td>
                        <td>432 B</td>
                        <td>Corner cubie transformation</td>
                    </tr>
                    <tr>
                        <td><strong>CubeSymmetry</strong></td>
                        <td>cornermove[2187][18]</td>
                        <td>40 KB</td>
                        <td>Phase 1 corner coord transform</td>
                    </tr>
                    <tr>
                        <td><strong>CubeSymmetry</strong></td>
                        <td>edgeomove[2048][18]</td>
                        <td>36 KB</td>
                        <td>Phase 1 edge orient coord transform</td>
                    </tr>
                    <tr>
                        <td><strong>CubeSymmetry</strong></td>
                        <td>edgepmove[495][18]</td>
                        <td>9 KB</td>
                        <td>Phase 1 edge perm coord transform</td>
                    </tr>
                    <tr>
                        <td><strong>permcube</strong></td>
                        <td>eperm_move[495][18]</td>
                        <td>9 KB</td>
                        <td>Phase 2 edge perm transform</td>
                    </tr>
                    <tr>
                        <td><strong>permcube</strong></td>
                        <td>cperm_move[70][18]</td>
                        <td>1.2 KB</td>
                        <td>Phase 2 corner perm transform</td>
                    </tr>
                </table>
                
                <h3>Pruning Tables (The Real Stars)</h3>
                <table>
                    <tr>
                        <th>Phase</th>
                        <th>Table Name</th>
                        <th>Size</th>
                        <th>Entries</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td><strong>Phase 1</strong></td>
                        <td>phase1_prun</td>
                        <td>~10 MB</td>
                        <td>2.2 billion</td>
                        <td>Minimum moves to G1 from any CubeSymmetry state</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 2</strong></td>
                        <td>phase2_prun</td>
                        <td>~40 MB</td>
                        <td>43.2 billion</td>
                        <td>Minimum moves to solved from any permcube state</td>
                    </tr>
                </table>
                
                <div class="success-box">
                    <p><strong>Why lookup tables are so powerful:</strong></p>
                    <ul>
                        <li>‚úÖ <strong>No computation:</strong> Just array access O(1)</li>
                        <li>‚úÖ <strong>Cache-friendly:</strong> Locality of reference</li>
                        <li>‚úÖ <strong>Pre-computed:</strong> All work done once at startup</li>
                        <li>‚úÖ <strong>Tight bounds:</strong> Pruning eliminates 99% of search space</li>
                    </ul>
                </div>
            </section>
            
            <!-- Complete Example -->
            <section id="example">
                <h2><span class="emoji">üìù</span>Complete Example: Solving a Scrambled Cube</h2>
                
                <div class="example">
                    <h3>Input</h3>
                    <pre>Scrambled cube in Singmaster notation:
"R U R' U R U2 R' U"</pre>
                    
                    <h3>Step-by-Step</h3>
                    
                    <h4>1. Parse Input</h4>
                    <pre>Parser ‚Üí cubepos
  Convert notation to internal representation
  Now we have: 8 corners + 12 edges, all encoded</pre>
                    
                    <h4>2. Phase 1: Get to G1</h4>
                    <pre>cubepos ‚Üí CubeSymmetry
  csymm = <calculate corner orientation>
  eosymm = <calculate edge orientation>
  epsymm = <calculate middle edge placement>
  
Iterative deepening:
  Depth 1: Check all single moves
    Lookup pruning_table[new_state]
    If ‚â§ 0: FOUND (G1 reached!)
    If > 0: continue searching
  
  Depth 2: Check all two-move combinations
    ...
  
  Depth 8: FOUND!
  Phase 1 solution: "R U2 R' U' R U R' U R U2 R'"
  (8 moves to reach G1)</pre>
                    
                    <h4>3. Phase 2: Solve Completely</h4>
                    <pre>CubeSymmetry ‚Üí permcube
  et = <calculate top layer edge perm>
  em = <calculate middle layer edge perm>
  eb = <calculate bottom layer edge perm>
  c8_4 = <calculate corner placement>
  
Iterative deepening:
  Depth 1: Check single half-turns
  Depth 2: Check two-move combinations
  ...
  Depth 6: FOUND!
  Phase 2 solution: "F2 D B2 D' F2"
  (6 moves to solve)</pre>
                    
                    <h4>4. Combine Solutions</h4>
                    <pre>Final solution:
  Phase 1 (8 moves) + Phase 2 (6 moves) = 14 moves total
  
  "R U2 R' U' R U R' U R U2 R' F2 D B2 D' F2"</pre>
                    
                    <h3>Results</h3>
                    <pre>‚úÖ Input: R U R' U R U2 R' U (scramble)
‚úÖ Solution: R U2 R' U' R U R' U R U2 R' F2 D B2 D' F2 (14 moves)
‚úÖ Time: ~microseconds on modern CPU
‚úÖ Optimal: Close to minimum possible</pre>
                </div>
            </section>
            
            <!-- Why This Works -->
            <section id="why">
                <h2><span class="emoji">üí°</span>Why This Algorithm is So Clever</h2>
                
                <div class="success-box">
                    <h3>1. Problem Decomposition</h3>
                    <p>Split one hard problem into two easier ones:</p>
                    <ul>
                        <li><strong>Phase 1:</strong> Orient all pieces (2.2B states)</li>
                        <li><strong>Phase 2:</strong> Place pieces correctly (43.2B states)</li>
                    </ul>
                    <p>Solving both in sequence is faster than solving either completely! ‚ö°</p>
                </div>
                
                <div class="success-box">
                    <h3>2. Coordinate Compression</h3>
                    <p>Don't work with 43 quintillion states‚Äîwork with billions:</p>
                    <ul>
                        <li><strong>cubepos:</strong> 20 bytes, complete but big</li>
                        <li><strong>CubeSymmetry:</strong> 6 bytes, compressed for Phase 1</li>
                        <li><strong>permcube:</strong> 9 bytes, permutation-focused</li>
                    </ul>
                    <p>Same information, different representations! üì¶</p>
                </div>
                
                <div class="success-box">
                    <h3>3. Symmetry Reduction</h3>
                    <p>The cube can be rotated 48 different ways, but they're equivalent. Group equivalent states, store only representatives:</p>
                    <ul>
                        <li>48x symmetry reduction in worst case</li>
                        <li>Cuts memory requirements dramatically</li>
                        <li>Only need one pruning table entry per equivalence class</li>
                    </ul>
                </div>
                
                <div class="success-box">
                    <h3>4. Efficient Pruning</h3>
                    <p>Pruning tables give tight lower bounds:</p>
                    <ul>
                        <li><strong>Exact:</strong> Pre-computed optimal distances</li>
                        <li><strong>Fast:</strong> Single table lookup O(1)</li>
                        <li><strong>Effective:</strong> Eliminates 99% of search branches</li>
                    </ul>
                    <p>If pruning_value > remaining_moves: skip entire subtree! üå≥</p>
                </div>
                
                <div class="success-box">
                    <h3>5. Move Lookup Tables</h3>
                    <p>No expensive computations needed:</p>
                    <ul>
                        <li>Pre-compute how each coordinate transforms with each move</li>
                        <li>When you need to apply a move: just array lookup!</li>
                        <li>Microsecond speeds for state transitions</li>
                    </ul>
                </div>
            </section>
            
            <!-- Memory Summary -->
            <section id="memory">
                <h2><span class="emoji">üíæ</span>Memory Requirements</h2>
                
                <table>
                    <tr>
                        <th>Component</th>
                        <th>Size</th>
                        <th>Purpose</th>
                    </tr>
                    <tr>
                        <td colspan="3"><strong>Move Lookup Tables</strong></td>
                    </tr>
                    <tr>
                        <td>cubepos transition tables</td>
                        <td>~1 KB</td>
                        <td>How moves transform pieces</td>
                    </tr>
                    <tr>
                        <td>CubeSymmetry move tables</td>
                        <td>~85 KB</td>
                        <td>Phase 1 coordinate transforms</td>
                    </tr>
                    <tr>
                        <td>permcube move tables</td>
                        <td>~10 KB</td>
                        <td>Phase 2 coordinate transforms</td>
                    </tr>
                    <tr>
                        <td colspan="3"><strong>Pruning Tables (The Big Ones)</strong></td>
                    </tr>
                    <tr>
                        <td>Phase 1 pruning table</td>
                        <td>~10 MB</td>
                        <td>Minimum moves to G1</td>
                    </tr>
                    <tr>
                        <td>Phase 2 pruning table</td>
                        <td>~40 MB</td>
                        <td>Minimum moves to solved</td>
                    </tr>
                    <tr>
                        <td colspan="3"><strong>Total</strong></td>
                    </tr>
                    <tr>
                        <td><strong>Total Memory</strong></td>
                        <td><strong>~50 MB</strong></td>
                        <td>Fits easily in L3 cache!</td>
                    </tr>
                </table>
                
                <div class="highlight">
                    <p><strong>50 MB is tiny!</strong> For comparison:</p>
                    <ul>
                        <li>A single HD photo: 10-15 MB</li>
                        <li>A 30-second video clip: 100-500 MB</li>
                        <li>Modern RAM: 8-32 GB</li>
                    </ul>
                    <p>So we can solve ANY scrambled cube in microseconds with trivial memory! üöÄ</p>
                </div>
            </section>
            
            <!-- Final Summary -->
            <section id="final">
                <h2><span class="emoji">‚ú®</span>The Complete Picture</h2>
                
                <div class="success-box">
                    <h3>Three Data Structures Working in Harmony:</h3>
                    
                    <p><strong>cubepos:</strong> The complete, uncompressed state</p>
                    <ul>
                        <li>Used for input/output and general manipulation</li>
                        <li>Can perform any move</li>
                        <li>20 bytes per state</li>
                    </ul>
                    
                    <p><strong>CubeSymmetry:</strong> Phase 1's optimized coordinates</p>
                    <ul>
                        <li>Only tracks what matters for orientation solving</li>
                        <li>6 bytes per state</li>
                        <li>2.2 billion different states (vs. 43 quintillion)</li>
                    </ul>
                    
                    <p><strong>permcube:</strong> Phase 2's permutation focus</p>
                    <ul>
                        <li>Only tracks positions (orientations solved)</li>
                        <li>9 bytes per state</li>
                        <li>43.2 billion different states</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <h3>The Flow:</h3>
                    <pre>Scrambled Cube
       ‚Üì
   cubepos (parse)
       ‚Üì
   CubeSymmetry (compress for Phase 1)
       ‚Üì
   Phase 1 Search: Get to G1 (~12 moves max)
       ‚Üì
   permcube (convert for Phase 2)
       ‚Üì
   Phase 2 Search: Solve completely (~18 moves max)
       ‚Üì
   SOLUTION ‚â§ 20 moves ‚ú®</pre>
                </div>
                
                <div class="success-box">
                    <h3>Why It Works So Well:</h3>
                    <ul>
                        <li>‚úÖ <strong>Smart representation:</strong> Different data structures for different phases</li>
                        <li>‚úÖ <strong>Coordinate compression:</strong> 20,000x reduction in state space</li>
                        <li>‚úÖ <strong>Efficient lookups:</strong> Pre-computed tables, no expensive calculations</li>
                        <li>‚úÖ <strong>Effective pruning:</strong> Eliminates 99% of search branches</li>
                        <li>‚úÖ <strong>Tiny memory:</strong> 50 MB total (fits in cache)</li>
                        <li>‚úÖ <strong>Guaranteed optimal:</strong> Always finds solution ‚â§ 20 moves</li>
                    </ul>
                </div>
            </section>
        </div>
        
        <footer>
            <p>üß© The beauty of computer science: Smart algorithms beat brute force.</p>
            <p><em>Kociemba's algorithm: Taking an impossible problem and making it trivial through clever representation!</em></p>
        </footer>
    </div>
</body>
</html>