#include "phase1.h"
#include <iostream>
#include <cstdio>

/*
===============================================================================
 PHASE1.CPP - PHASE 1 PRUNING TABLE GENERATION & LOOKUP
===============================================================================

PURPOSE:
    Implements the generation, lookup, and file I/O for the Phase 1 pruning table.
    Used to reduce the cube to the Kociemba subgroup (G1) using symmetry coordinates.

KEY FUNCTIONS:
    - gen_table(): Builds pruning table via breadth-first search over all coordinates
    - lookup(): Returns minimum distance to subgroup for a given CubeSymmetry
    - read_table()/write_table(): Loads/saves table from disk with checksum

ALGORITHM OVERVIEW:
    - Table is generated by BFS from solved state, marking minimal move counts
    - Each entry encodes the minimal number of moves to reach G1
    - Table is loaded from disk if available, otherwise generated and saved

NOTES:
    - Table size: CORNERRSYMM × EDGEOSYMM × EDGEPERM entries
    - Used by TwophaseSolver for Phase 1 IDA* search
*/

using namespace std;

unsigned int phase1::memsize;
unsigned char* phase1::mem;
int phase1::file_checksum;
const char* const phase1::filename = "data1.dat";

void phase1::gen_table() {
    memset(mem, -1, memsize);
    mem[0] = 0;
    int seen = 1;

    cout << "Gen phase1" << flush;

    for (int d = 1; ; d++) {
        int lastiter = (seen == CORNERRSYMM * EDGEOSYMM * EDGEPERM);
        int seek = d - 1;
        int at = 0;

        for (int cs = 0; cs < CORNERRSYMM; cs++) {
            int csymm = CubeSymmetry::cornersymm_expand[cs];
            for (int eosymm = 0; eosymm < EDGEOSYMM; eosymm++)
                for (int epsymm = 0; epsymm < EDGEPERM; epsymm++, at += BYTES_PER_ENTRY)
                    if (mem[at] == seek) {
                        int deltadist[NMOVES];
                        for (int mv = 0; mv < NMOVES; mv++) {
                            int rd = 0;
                            CubeSymmetry kc(csymm, eosymm, epsymm);
                            kc.move(mv);
                            corner_mapinfo& cm = CubeSymmetry::cornersymm[kc.csymm];
                            for (int m = cm.minmap; cm.minbits >> m; m++)
                                if ((cm.minbits >> m) & 1) {
                                    int deosymm = CubeSymmetry::edgeomap[CubeSymmetry::edgepxor[kc.epsymm][m >> 3] ^ kc.eosymm][m];
                                    int depsymm = CubeSymmetry::edgepmap[kc.epsymm][m];
                                    int dat = ((cm.csymm * EDGEOSYMM + deosymm) * EDGEPERM + depsymm) * BYTES_PER_ENTRY;
                                    rd = mem[dat];
                                    if (rd == 255) {
                                        rd = d;
                                        mem[dat] = rd;
                                        seen++;
                                    }
                                }
                            deltadist[mv] = rd - seek;
                        }

                        for (int b = 0; b < 3; b++) {
                            int v = 0;
                            int clim = 1;
                            for (int c = clim; c >= 0; c--) {
                                int vv = 0;
                                int cnts[3];
                                cnts[0] = cnts[1] = cnts[2] = 0;
                                for (int t = 2; t >= 0; t--) {
                                    vv = 2 * vv + deltadist[3 * b + 9 * c + t];
                                    cnts[1 + deltadist[3 * b + 9 * c + t]]++;
                                }
                                if (cnts[0] > 0 && cnts[2] > 0)
                                    error("! bad delta distance values within one face turn set");
                                if (cnts[0])
                                    vv += 7;
                                else
                                    vv += 8;
                                v = 16 * v + vv;
                            }
                            mem[at + b + 1] = v;
                        }
                    }
        }

        cout << "[phase1:" << (d * 100 / 14) << "%]" << endl << flush;
        if (lastiter)
            break;
    }

    cout << "[phase1:100%]" << endl << flush;
}

int phase1::read_table() {
    FILE* f = fopen(filename, "rb");
    if (f == 0)
        return 0;

    int togo = memsize;
    unsigned char* p = mem;
    int seed = 0;

    while (togo > 0) {
        unsigned int siz = (togo > TABLE_CHUNKSIZE ? TABLE_CHUNKSIZE : togo);
        if (fread(p, 1, siz, f) != siz) {
            cerr << "Out of data in " << filename << endl;
            fclose(f);
            return 0;
        }
        seed = datahash((unsigned int*)p, siz, seed);
        togo -= siz;
        p += siz;
    }

    if (fread(&file_checksum, sizeof(int), 1, f) != 1) {
        cerr << "Out of data in " << filename << endl;
        fclose(f);
        return 0;
    }
    fclose(f);

    if (file_checksum != datahash((unsigned int*)mem, memsize, 0)) {
        cerr << "Bad checksum in " << filename << endl;
        return 0;
    }
    return 1;
}

void phase1::write_table() {
    FILE* f = fopen(filename, "wb");
    if (f == 0)
        error("! cannot write pruning file to current directory");
    if (fwrite(mem, 1, memsize, f) != memsize)
        error("! error writing pruning table");
    if (fwrite(&file_checksum, sizeof(int), 1, f) != 1)
        error("! error writing pruning table");
    fclose(f);
}

int phase1::lookup(const CubeSymmetry& kc) {
    corner_mapinfo& cm = CubeSymmetry::cornersymm[kc.csymm];
    int m = cm.minmap;
    int r = mem[BYTES_PER_ENTRY * (((cm.csymm * EDGEOSYMM) +
            CubeSymmetry::edgeomap[CubeSymmetry::edgepxor[kc.epsymm][m >> 3] ^ kc.eosymm][m]) * 495 +
            CubeSymmetry::edgepmap[kc.epsymm][m])];
    return r;
}

int phase1::lookup(const CubeSymmetry& kc, int togo, int& nextmovemask) {
    corner_mapinfo& cm = CubeSymmetry::cornersymm[kc.csymm];
    int m = cm.minmap;
    int off = BYTES_PER_ENTRY * (((cm.csymm * EDGEOSYMM) +
              CubeSymmetry::edgeomap[CubeSymmetry::edgepxor[kc.epsymm][m >> 3] ^ kc.eosymm][m]) * EDGEPERM +
              CubeSymmetry::edgepmap[kc.epsymm][m]);
    int r = mem[off];

    if (togo > 0) {
        nextmovemask = 0;
        for (int b = 0; b < 3; b++) {
            int v = mem[off + 1 + b];
            for (int c = 0; c < 2; c++) {
                int vv = v & 15;
                v >>= 4;
                int inc = vv >= 8;
                vv = (vv - 8) & 7;
                for (int t = 0; t < 3; t++) {
                    int thisv = (inc ? 1 : -1) * (vv & 1);
                    vv >>= 1;
                    if (r + thisv <= togo)
                        nextmovemask |= 1 << (3 * b + 9 * c + t);
                }
            }
        }
    }
    return r;
}

int phase1::lookup(const CubeSymmetry& kc, int& mask) {
    corner_mapinfo& cm = CubeSymmetry::cornersymm[kc.csymm];
    int m = cm.minmap;
    int off = BYTES_PER_ENTRY * (((cm.csymm * EDGEOSYMM) +
              CubeSymmetry::edgeomap[CubeSymmetry::edgepxor[kc.epsymm][m >> 3] ^ kc.eosymm][m]) * EDGEPERM +
              CubeSymmetry::edgepmap[kc.epsymm][m]);

    mask = 0;
    for (int b = 0; b < 3; b++) {
        int v = mem[off + 1 + b];
        for (int c = 0; c < 2; c++) {
            int vv = v & 15;
            v >>= 4;
            int inc = vv >= 8;
            vv = (vv - 8) & 7;
            for (int t = 0; t < 3; t++) {
                int thisv = (inc ? 1 : -1) * (vv & 1);
                vv >>= 1;
                if (thisv <= 0)
                    mask |= 1 << (3 * b + 9 * c + t);
            }
        }
    }
    return mem[off];
}


void phase1::init(int suppress_writing) {
    static int initialized = 0;
    if (initialized)
        return;
    initialized = 1;

    CubeSymmetry::init();

    memsize = BYTES_PER_ENTRY * CORNERRSYMM * EDGEOSYMM * EDGEPERM;
    mem = new unsigned char[memsize];

    if (!read_table()) {
        gen_table();
        file_checksum = datahash((unsigned int*)mem, memsize, 0);
        if (!suppress_writing)
            write_table();
    }
}
